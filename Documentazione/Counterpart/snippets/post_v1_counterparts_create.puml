@startuml
title Flusso Counterpart API - POST /v1/counterparts

actor Client as C
participant "Counterpart API BS (borepurposingmgmt)" as API_BS
participant "Counterpart Service BS (borepurposingmgmt)" as Service_BS
participant "Counterpart API MS (meRepurposingReg)" as API_MS
participant "Document Node Service" as NODE_SRV
database "Database" as DB

== Richiesta di creazione ==
C -> API_BS : POST /v1/counterparts\nBody: CounterpartDTORequest {name, vatNumber, country, registeredOffice, ..}
activate API_BS

API_BS -> Service_BS : Inoltra richiesta di creazione (CREATE_COUNTERPART)
activate Service_BS

note right of Service_BS
- Il JSON CounterpartDTORequest viene convertito in oggetto e wrappato per la creazione multipla
- WrapperCounterpartCreateDTORequest -> JSON (Prepara la richiesta per MS)
end note

Service_BS -> Service_BS : Inoltra la richiesta a CREATE_COUNTERPART_MULTI 
Service_BS -> API_MS : POST {meRepurposingRegEndPoint}/v1/counterparts/multi\nBody: WrapperCounterpartCreateDTORequest{ items[] }
activate API_MS

API_MS -> DB : Inserisce nuovi record Counterpart
DB --> API_MS : Esito creazione OK / errore
API_MS --> Service_BS : - JSON Response 201 CREATED: CreateMultiDTOResponse {ids[]} \n- Error Response 400 / 409 / 500
deactivate API_MS

== Creazione asincrona dei document node ==
note right of Service_BS
Il servizio avvia in parallelo il flusso per creare i "document node" e aggiornare i Counterpart con il nodeId.
end note

Service_BS -> Service_BS : Avvia CREATE_NODE_FOR_COUNTERPART_LIST
activate Service_BS

Service_BS -> Service_BS : JSON â†’ CreateMultiDTOResponse\nRecupera lista ID counterpart 

== Ricerca dei counterpart creati ==
Service_BS -> Service_BS : Invoca il processo di ricerca dei Counterpart creati per leggerne i dati SEARCH_COUNTERPART_FOR_CREATE_NODE
loop Per ogni pagina di risultati
    Service_BS -> Service_BS : Invoca route interna SEARCH_COUNTERPART
    Service_BS -> API_MS : POST {meRepurposingRegEndPoint}/v1/counterparts/search\nBody: CounterpartSearchDTORequest { ids[], page, pageSize, name, vatNumber, countries[], ..}
    activate API_MS
    API_MS -> DB : Query Counterpart per ID con paginazione
    DB --> API_MS : Esito ricerca
    API_MS --> Service_BS : - JSON Response 200 OK: WrapperCounterpartDTOResponse { items[], stats } \n- Error Response 404 / 500
    deactivate API_MS
end loop

== Creazione dei document node ==
loop Per ogni Counterpart trovato
    Service_BS -> NODE_SRV : POST /v1/documents/nodes\nBody: CreateNodeDTORequest { parentId, name, nodeType, ..}
    activate NODE_SRV
    NODE_SRV --> Service_BS : - 201 CREATED \nBody: NodeDTOResponse { nodeId }
    deactivate NODE_SRV
    Service_BS -> Service_BS : Aggiorna lista Counterpart con nodeId
end loop

== Aggiornamento finale dei Counterpart ==
Service_BS -> API_MS : PATCH {meRepurposingRegEndPoint}/v1/counterparts/multi\nBody: WrapperCounterpartUpdateDTORequest { items[] }
activate API_MS
API_MS -> DB : Aggiorna record Counterpart con nodeId
DB --> API_MS : Esito aggiornamento
API_MS --> Service_BS : - 204 NO CONTENT \n- Error Response 400 / 404 / 500
deactivate API_MS

Service_BS --> API_BS : Restituisce esito
deactivate Service_BS

API_BS --> C : - 201 CREATED \n- 400 / 409 / 500 Error Response
deactivate API_BS

@enduml
